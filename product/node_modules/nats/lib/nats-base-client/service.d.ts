import { Deferred } from "./util";
import { Msg, MsgHdrs, Nanos, NatsConnection, NatsError, PublishOptions, Sub } from "./types";
import { QueuedIterator, QueuedIteratorImpl } from "./queued_iterator";
/**
 * Services have common backplane subject pattern:
 *
 * `$SRV.PING|STATS|INFO|SCHEMA` - pings or retrieves status for all services
 * `$SRV.PING|STATS|INFO|SCHEMA.<name>` - pings or retrieves status for all services having the specified name
 * `$SRV.PING|STATS|INFO|SCHEMA.<name>.<id>` - pings or retrieves status of a particular service
 *
 * Note that <name> and <id> are upper-cased.
 */
export declare const ServiceApiPrefix = "$SRV";
export declare const ServiceErrorHeader = "Nats-Service-Error";
export declare const ServiceErrorCodeHeader = "Nats-Service-Error-Code";
export declare enum ServiceVerb {
    PING = "PING",
    STATS = "STATS",
    INFO = "INFO",
    SCHEMA = "SCHEMA"
}
export declare enum ServiceResponseType {
    STATS = "io.nats.micro.v1.stats_response",
    INFO = "io.nats.micro.v1.info_response",
    PING = "io.nats.micro.v1.ping_response",
    SCHEMA = "io.nats.micro.v1.schema_response"
}
export interface ServiceResponse {
    /**
     * Response type schema
     */
    type: ServiceResponseType;
}
export type ServiceIdentity = ServiceResponse & {
    /**
     * The kind of the service reporting the stats
     */
    name: string;
    /**
     * The unique ID of the service reporting the stats
     */
    id: string;
    /**
     * A version for the service
     */
    version: string;
};
export interface ServiceMsg extends Msg {
    respondError(code: number, description: string, data?: Uint8Array, opts?: PublishOptions): boolean;
}
export declare class ServiceMsgImpl implements ServiceMsg {
    msg: Msg;
    constructor(msg: Msg);
    get data(): Uint8Array;
    get sid(): number;
    get subject(): string;
    respond(data?: Uint8Array, opts?: PublishOptions): boolean;
    respondError(code: number, description: string, data?: Uint8Array, opts?: PublishOptions): boolean;
}
export interface ServiceGroup {
    /**
     * The name of the endpoint must be a simple subject token with no wildcards
     * @param name
     * @param opts is either a handler or a more complex options which allows a
     *  subject, handler, and/or schema
     */
    addEndpoint(name: string, opts?: ServiceHandler | EndpointOptions): QueuedIterator<ServiceMsg>;
    /**
     * A group is a subject prefix from which endpoints can be added.
     * Can be empty to allow for prefixes or tokens that are set at runtime
     * without requiring editing of the service.
     * @param subject
     */
    addGroup(subject?: string): ServiceGroup;
}
export declare class ServiceGroupImpl implements ServiceGroup {
    subject: string;
    srv: ServiceImpl;
    constructor(parent: ServiceGroup, name?: string);
    calcSubject(root: string, name?: string): string;
    addEndpoint(name?: string, opts?: ServiceHandler | EndpointOptions): QueuedIterator<ServiceMsg>;
    addGroup(name?: string): ServiceGroup;
}
export interface Service extends ServiceGroup, QueuedIterator<ServiceMsg> {
    /**
     * A promise that gets resolved to null or Error once the service ends.
     * If an error, then service exited because of an error.
     */
    stopped: Promise<null | Error>;
    /**
     * True if the service is stopped
     */
    isStopped: boolean;
    /**
     * Returns the stats for the service.
     */
    stats(): Promise<ServiceStats>;
    /**
     * Returns a service info for the service
     */
    info(): ServiceInfo;
    /**
     * Resets all the stats
     */
    reset(): void;
    /**
     * Stop the service returning a promise once the service completes.
     * If the service was stopped due to an error, that promise resolves to
     * the specified error
     */
    stop(err?: Error): Promise<null | Error>;
}
export type NamedEndpointStats = {
    /**
     * The name of the endpoint
     */
    name: string;
    /**
     * The subject the endpoint is listening on
     */
    subject: string;
    /**
     * The number of requests received by the endpoint
     */
    num_requests: number;
    /**
     * Number of errors that the endpoint has raised
     */
    num_errors: number;
    /**
     * If set, the last error triggered by the endpoint
     */
    last_error?: string;
    /**
     * A field that can be customized with any data as returned by stats handler see {@link ServiceConfig}
     */
    data?: unknown;
    /**
     * Total processing_time for the service
     */
    processing_time: Nanos;
    /**
     * Average processing_time is the total processing_time divided by the num_requests
     */
    average_processing_time: Nanos;
};
/**
 * Statistics for an endpoint
 */
export type EndpointStats = ServiceIdentity & {
    endpoints?: NamedEndpointStats[];
    /**
     * ISO Date string when the service started
     */
    started: string;
};
export type ServiceSchema = ServiceIdentity & {
    api_url?: string;
    endpoints: EndpointSchema[];
};
export type SchemaInfo = {
    request: string;
    response: string;
};
export type EndpointSchema = {
    /**
     * Endpoint Name
     */
    name: string;
    /**
     * Subject the endpoint receiving requests on
     */
    subject: string;
    /**
     * Optional schema if defined
     */
    schema?: SchemaInfo;
};
export type ServiceInfo = ServiceIdentity & {
    /**
     * Description for the service
     */
    description: string;
    /**
     * Subject where the service can be invoked
     */
    subjects: string[];
};
export type ServiceConfig = {
    /**
     * A type for a service
     */
    name: string;
    /**
     * A version identifier for the service
     */
    version: string;
    /**
     * Description for the service
     */
    description?: string;
    /**
     * Schema for the service
     */
    apiURL?: string;
    /**
     * An optional endpoint mapping a handler to a subject.
     * More complex multi-endpoint services can be achieved by
     * {@link Service}.addEndpoint() and addGroup().
     */
    endpoint?: Endpoint;
    /**
     * A customized handler for the stats of an endpoint. The
     * data returned by the endpoint will be serialized as is
     * @param endpoint
     */
    statsHandler?: (endpoint: Endpoint) => Promise<unknown | null>;
};
export type ServiceHandler = (err: NatsError | null, msg: ServiceMsg) => void;
/**
 * A service Endpoint
 */
export type Endpoint = {
    /**
     * Subject where the endpoint listens
     */
    subject: string;
    /**
     * An optional handler - if not set the service is an iterator
     * @param err
     * @param msg
     */
    handler?: ServiceHandler;
    /**
     * An optional schema
     */
    schema?: SchemaInfo;
};
export type EndpointOptions = Partial<Endpoint>;
/**
 * The stats of a service
 */
export type ServiceStats = ServiceIdentity & EndpointStats;
type NamedEndpoint = {
    name: string;
} & Endpoint;
type ServiceSubscription<T = unknown> = NamedEndpoint & {
    internal: boolean;
    sub: Sub<T>;
    qi?: QueuedIterator<T>;
    stats: NamedEndpointStatsImpl;
    schema?: SchemaInfo;
};
export declare class ServiceError extends Error {
    code: number;
    constructor(code: number, message: string);
    static isServiceError(msg: Msg): boolean;
    static toServiceError(msg: Msg): ServiceError | null;
}
export declare class ServiceImpl extends QueuedIteratorImpl<ServiceMsg> implements Service {
    nc: NatsConnection;
    _id: string;
    config: ServiceConfig;
    handlers: ServiceSubscription[];
    internal: ServiceSubscription[];
    _stopped: boolean;
    _done: Deferred<Error | null>;
    _schema?: Uint8Array;
    started: string;
    /**
     * @param verb
     * @param name
     * @param id
     * @param prefix - this is only supplied by tooling when building control subject that crosses an account
     */
    static controlSubject(verb: ServiceVerb, name?: string, id?: string, prefix?: string): string;
    constructor(nc: NatsConnection, config?: ServiceConfig);
    get subjects(): string[];
    get id(): string;
    get name(): string;
    get description(): string;
    get version(): string;
    errorToHeader(err: Error): MsgHdrs;
    setupHandler(h: NamedEndpoint, internal?: boolean): ServiceSubscription;
    info(): ServiceInfo;
    stats(): Promise<ServiceStats>;
    addInternalHandler(verb: ServiceVerb, handler: (err: NatsError | null, msg: Msg) => Promise<void>): void;
    _doAddInternalHandler(name: string, verb: ServiceVerb, handler: (err: NatsError | null, msg: Msg) => Promise<void>, kind?: string, id?: string): void;
    start(): Promise<Service>;
    close(err?: Error): Promise<null | Error>;
    get stopped(): Promise<null | Error>;
    get isStopped(): boolean;
    stop(err?: Error): Promise<null | Error>;
    schema(): ServiceSchema;
    reset(): void;
    addGroup(name: string): ServiceGroup;
    addEndpoint(name: string, handler?: ServiceHandler | EndpointOptions): QueuedIterator<ServiceMsg>;
    _addEndpoint(e: NamedEndpoint, main?: boolean): QueuedIterator<ServiceMsg>;
}
declare class NamedEndpointStatsImpl implements NamedEndpointStats {
    name: string;
    subject: string;
    average_processing_time: Nanos;
    num_requests: number;
    processing_time: Nanos;
    num_errors: number;
    last_error?: string;
    data?: unknown;
    constructor(name: string, subject: string);
    reset(qi?: QueuedIterator<unknown>): void;
    countLatency(start: number): void;
    countError(err: Error): void;
    _stats(): NamedEndpointStats;
    stats(qi?: QueuedIterator<unknown>): NamedEndpointStats;
}
export {};
